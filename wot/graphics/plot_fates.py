import numpy as np
import pandas as pd
from matplotlib import patches
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import math

import wot.graphics

class Fate_Plotter():
    
    def __init__(self, fate_ds):
        """
        Parameters
        ----------
        fate_ds: pandas.DataFrame
            A df of cell fates as generated by wot.tmap.TransportMapModel.fates.
        """
        self.fate_ds = fate_ds
    
    def plot_triangle(self, name1, name2, day, filename=None):
        """
        Plots cells in barycentric coordinates (2D) according to their fates.
        Cells are placed by using the fates to generate a convex combination
        of the triangle's vertices.

        Parameters
        ----------
        name1: str
            The cell population whose fate will the first of the triangle's vertices.
        name2: str
            The cell population whose fate will the second of the triangle's vertices.
        day: float
            The timepoint from which we want to plot cells.
        filename: str, optional
            The name of the file to save the plot as. None to skip saving.
        """

        figure = plt.figure(figsize=(10, 10))   

        #Get the fates for our two cell populations
        fate1 = self.fate_ds[:,name1][self.fate_ds.obs['day']==day].X.flatten()
        fate2 = self.fate_ds[:,name2][self.fate_ds.obs['day']==day].X.flatten()

        #Take a convex combination of the triangle's vertices using the fates
        Nrows = len(fate1)
        x = np.zeros(Nrows)
        y = np.zeros(Nrows)
        P = np.array([[1,0],[np.cos(2*math.pi/3),math.sin(2*math.pi/3)],[math.cos(4*math.pi/3),math.sin(4*math.pi/3)]])

        for i in range(0,Nrows):
            ff = np.array([fate1[i],fate2[i],1-(fate1[i]+fate2[i])])
            x[i] = (ff @ P)[0]
            y[i] = (ff @ P)[1]

        #Plot the triangle
        t1 = plt.Polygon(P, color=(0,0,0,0.1))
        plt.gca().add_patch(t1)

        #Plot the vertices
        vx = P[:,0]
        vy = P[:,1]
        plt.scatter(vx,vy)

        #Plot cells and labels
        plt.scatter(x, y, c='tab:blue')
        plt.text(P[0,0]+.1, P[0,1], name1)
        plt.text(P[1,0]-.1, P[1,1]+.1, name2)
        plt.text(P[2,0]-.1, P[2,1]-.2, 'Other')
        plt.axis('equal')
        plt.axis('off')

        plt.title('{} vs. {} on day {}'.format(name1, name2, day))

        #Optionally save the figure
        if filename is not None:
            plt.savefig(filename)

    def plot_tetrahedron(self, name1, name2, name3, day, 
                         azimuth=40, elevation=20, filename=None):
        """
        Plots cells in barycentric coordinates (3D) according to their fates.
        Cells are placed by using the fates to generate a convex combination
        of a tetrahedron's vertices. Works well with the "%matplotlib widget"
        cell magic if used in Jupyter notebooks.

        Parameters
        ----------
        name1: str
            The cell population whose fate will the first of the tetrahedron's vertices.
        name2: str
            The cell population whose fate will the second of the tetrahedron's vertices.
        name3: str
            The cell population whose fate will the third of the tetrahedron's vertices.
        day: float
            The timepoint at which we want to plot cells.
        azimuth: float, optional
            The angle in degrees by which to rotate the xy plane. The face made by
            name1, name2, and name3 is normal to the xy plane.
        elevation: float, optional
            The angle in degrees by which to rotate the z plane. 
        filename: str, optional
            The name of the file to save the plot as. None to skip saving.
        """   
        # Map the time to the closest time in the dataset
        days = pd.unique(self.fate_ds.obs.day)
        day = days[np.argmin(abs(days - day))]

        fate1 = self.fate_ds[:,name1][self.fate_ds.obs['day']==day].X.flatten()
        fate2 = self.fate_ds[:,name2][self.fate_ds.obs['day']==day].X.flatten()
        fate3 = self.fate_ds[:,name3][self.fate_ds.obs['day']==day].X.flatten()

        Nrows = len(fate1)
        x = np.zeros(Nrows)
        y = np.zeros(Nrows)
        z = np.zeros(Nrows)

        # Define coordinates for the vertices of the tetrahedron
        T = np.array([[ math.sqrt(8/9), 0, -1/3],
                      [-math.sqrt(2/9), math.sqrt(2/3), -1/3],
                      [ -math.sqrt(2/9), -math.sqrt(2/3), -1/3],
                      [ 0, 0, 1]])

        # Find the coordinates of each cell as a linear combination of the weight 
        # of the cell towards each vertex fate.
        for i in range(0,Nrows):
            ff = np.array([fate1[i],fate2[i], fate3[i], 1-(fate1[i]+fate2[i]+fate3[i])])
            x[i] = (ff @ T)[0]
            y[i] = (ff @ T)[1]
            z[i] = (ff @ T)[2]

        # Close the previous plot
        plt.close()

        # Create the plot and set axes settings
        fig = plt.figure(figsize=(8,8))
        ax = fig.add_subplot(111, projection='3d')

        # Plot the cells
        ax.scatter(xs=x, ys=y, zs=z, zdir='z', s=4, c='tab:blue', depthshade=True)

        # Plot the vertices
        ax.scatter(xs=T[:,0], ys=T[:,1], zs=T[:,2], zdir='z', s=20, c='orange', depthshade=True)

        #Plot the labels, offsetting them from the vertices by a small factor
        fate_names = [name1, name2, name3, 'Other']
        for x,y,z,fate in zip(T[:,0] + 0.1*np.sign(T[:,0]), 
                              T[:,1] + 0.05*np.sign(T[:,1]), 
                              T[:,2] + 0.05*np.sign(T[:,2]), fate_names):
            ax.text(x,y,z,fate,zdir=None)

        # Plot the faces of the tetrahedron
        ax.add_collection3d(Poly3DCollection(T[(0,1,2),:], color=(0.6,0.6,0.6), alpha=.05))
        ax.add_collection3d(Poly3DCollection(T[(0,1,3),:], color=(0.6,0.6,0.6), alpha=.05))
        ax.add_collection3d(Poly3DCollection(T[(0,2,3),:], color=(0.6,0.6,0.6), alpha=.05))
        ax.add_collection3d(Poly3DCollection(T[(1,2,3),:], color=(0.6,0.6,0.6), alpha=.05))

        # Set the angle of the plot
        ax.view_init(elev=elevation, azim=azimuth)

        # Turn off axes and trim extra space
        plt.axis('off')
        plt.title('{} vs. {} vs. {} on day {}'.format(name1, name2, name3, day))
        plt.tight_layout()

        #Optionally save the figure
        if filename is not None:
            plt.savefig(filename)

    def plot_log_odds(self, name1, name2, filename=None):
        """
        Displays log-odds for a pair of fates. This is the log of the 
        ratio of fate probabilities.

        Parameters
        ----------
        name1: str
            The cell population whose fate will the numerator.
        name2: str
            The cell population whose fate will denominator.
        filename: str, optional
            The name of the file to save the plot as. None to skip saving.
        """
        figure = plt.figure(figsize=(10, 10))

        #Extract the fate probabilities for the two cell populations
        fate1 = self.fate_ds[:, name1].X
        fate2 = self.fate_ds[:, name2].X

        #Calculate the log odds
        p = np.log(1e-9 + np.divide(fate1, fate2, out=np.zeros_like(fate1), where=fate2 != 0))

        #Plot log-odds by day
        plt.scatter(self.fate_ds.obs['day'], p, s=4, marker=',', c='tab:blue')
        plt.xlabel('Day')
        plt.ylabel('Log Odds')
        plt.title('{} vs. {}'.format(name1, name2))

        #Optionally save the figure
        if filename is not None:
            plt.savefig(filename)